/**
 * Utilities for converting between user-friendly phrases and regex patterns
 */

/**
 * Escape special regex characters in a phrase
 */
function escapeRegex(phrase) {
    return phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Convert array of phrases to regex pattern
 * Example: ["tu nombre es", "su nombre es"] 
 * → "(?:tu nombre es|su nombre es)\\s*[:]?\\s*([^.!?\\n]+)"
 */
export function phrasesToPattern(phrases) {
    if (!phrases || phrases.length === 0) {
        return '';
    }

    // Escape each phrase and join with | (OR operator)
    const escapedPhrases = phrases.map(p => escapeRegex(p.trim())).filter(Boolean);

    if (escapedPhrases.length === 0) {
        return '';
    }

    // Create pattern: (?:phrase1|phrase2)\s*[:]?\s*([^.!?\n]+)
    const phrasesGroup = escapedPhrases.length === 1
        ? escapedPhrases[0]
        : `(?:${escapedPhrases.join('|')})`;

    return `${phrasesGroup}\\s*[:]?\\s*([^.!?\\n]+)`;
}

/**
 * Extract phrases from regex pattern (reverse operation)
 * Attempts to parse pattern back into phrases
 * Returns empty array if pattern doesn't match expected format
 */
export function patternToPhrases(pattern) {
    if (!pattern) {
        return [];
    }

    try {
        let core = pattern;

        // 1. Remove the standard capture suffixes generated by this tool
        // Matches: \s*[:]?\s*([^.!?\n]+)
        core = core.replace(/\\s\*\[\:\?\]\?\\s\*\(\[\^\.!\?\\n]\+\)$/, '');
        // Matches simple: \s*[:]?\s*(.*)
        core = core.replace(/\\s\*\[\:\?\]\?\\s\*\(.*\)$/, '');

        let phrases = [];

        // 2. Check if it follows the standard generated format: (?:phrase1|phrase2)
        // We only unwrap if it starts with (?: and ends with ) AND the pipe split seems safe
        if (core.startsWith('(?:') && core.endsWith(')')) {
            const inner = core.slice(3, -1);
            phrases = inner.split('|');
        } else {
            // Non-standard or single phrase. 
            // If it contains top-level pipes, we might want to split, but risk splitting nested groups.
            // For safety, let's treat as separate only if we are sure.
            // But to fix the user's issue with "buscandos+empleos", we should try to clean.
            phrases = [core];
        }

        // 3. Clean up each phrase
        return phrases.map(p => {
            let s = p;

            // Common regex replacements to make it readable
            s = s.replace(/\\s[\*\+]?/g, ' '); // \s* \s+ -> space
            s = s.replace(/\\b/g, '');         // \b -> empty
            s = s.replace(/\(\?\:/g, '');      // (?: -> empty
            s = s.replace(/[\(\)]/g, '');      // remove parenthesis
            s = s.replace(/\[\:\?\]\?/g, '');  // [:?]? -> empty
            s = s.replace(/\\/g, '');          // remove remaining backslashes
            s = s.replace(/\s+/g, ' ');        // collapse spaces

            return s.trim();
        }).filter(Boolean);

    } catch (error) {
        console.warn('Could not parse pattern to phrases:', error);
        return [pattern];
    }
}

/**
 * Validate that phrases are non-empty
 */
export function validatePhrases(phrases) {
    if (!Array.isArray(phrases) || phrases.length === 0) {
        return { valid: false, error: 'Debes agregar al menos una frase' };
    }

    const hasEmpty = phrases.some(p => !p || !p.trim());
    if (hasEmpty) {
        return { valid: false, error: 'Las frases no pueden estar vacías' };
    }

    return { valid: true };
}
